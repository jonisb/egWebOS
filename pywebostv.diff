diff -Naur ./connection.py D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/connection.py
--- ./connection.py	1900-01-00 00:00:00 +0000
+++ D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/connection.py	1900-01-00 00:00:00 +0000
@@ -137,7 +137,7 @@
     REGISTERED = 2
 
     def __init__(self, host):
-        ws_url = "ws://{}:3000/".format(host)
+        ws_url = "ws://{0}:3000/".format(host)
         super(WebOSClient, self).__init__(ws_url)
         self.waiters = {}
         self.waiter_lock = RLock()
diff -Naur ./controls.py D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/controls.py
--- ./controls.py	1900-01-00 00:00:00 +0000
+++ D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/controls.py	1900-01-00 00:00:00 +0000
@@ -5,7 +5,7 @@
     # after try for python >= 3.10
     from typing import Callable
 
-from queue import Empty
+from Queue import Empty
 from uuid import uuid4
 
 from pywebostv.connection import WebOSWebSocketClient
@@ -39,7 +39,10 @@
     if isinstance(obj, list):
         return [process_payload(item, *args, **kwargs) for item in obj]
     elif isinstance(obj, dict):
-        return {k: process_payload(v, *args, **kwargs) for k, v in obj.items()}
+        _ = {}
+        for k, v in obj.items():
+            _[k] = process_payload(v, *args, **kwargs)
+        return _
     elif isinstance(obj, Callable):
         return obj(*args, **kwargs)
     else:
diff -Naur ./discovery.py D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/discovery.py
--- ./discovery.py	1900-01-00 00:00:00 +0000
+++ D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/discovery.py	1900-01-00 00:00:00 +0000
@@ -64,6 +64,6 @@
                 break
 
     if hosts:
-        return {urlparse(x).hostname for x in locations}
+        return set(urlparse(x).hostname for x in locations)
     else:
-        return {x for x in locations}
+        return set(x for x in locations)
diff -Naur ./model.py D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/model.py
--- ./model.py	1900-01-00 00:00:00 +0000
+++ D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/model.py	1900-01-00 00:00:00 +0000
@@ -7,7 +7,7 @@
         return self.data[val]
 
     def __repr__(self):
-        return "<Application '{}'>".format(self["title"])
+        return "<Application '{0}'>".format(self["title"])
 
 
 class InputSource(object):
@@ -19,7 +19,7 @@
         return self.data[val]
 
     def __repr__(self):
-        return "<InputSource '{}'>".format(self["label"])
+        return "<InputSource '{0}'>".format(self["label"])
 
 
 class AudioOutputSource(object):
@@ -27,4 +27,4 @@
         self.data = data
 
     def __repr__(self):
-        return "<AudioOutputSource '{}'>".format(self.data)
+        return "<AudioOutputSource '{0}'>".format(self.data)
diff -Naur ./temp/connection.py D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/temp/connection.py
--- ./temp/connection.py	1900-01-00 00:00:00 +0000
+++ D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/temp/connection.py	1900-01-00 00:00:00 +0000
@@ -1,241 +0,0 @@
-# -*- coding: utf-8 -*-
-
-import json
-import time
-from threading import RLock
-from uuid import uuid4
-try:
-    from queue import Queue, Empty
-except ImportError:
-    from Queue import Queue, Empty
-
-from ws4py.client.threadedclient import WebSocketClient
-
-from pywebostv.discovery import discover
-
-
-SIGNATURE = ("eyJhbGdvcml0aG0iOiJSU0EtU0hBMjU2Iiwia2V5SWQiOiJ0ZXN0LXNpZ25pbm" +
-             "ctY2VydCIsInNpZ25hdHVyZVZlcnNpb24iOjF9.hrVRgjCwXVvE2OOSpDZ58hR" +
-             "+59aFNwYDyjQgKk3auukd7pcegmE2CzPCa0bJ0ZsRAcKkCTJrWo5iDzNhMBWRy" +
-             "aMOv5zWSrthlf7G128qvIlpMT0YNY+n/FaOHE73uLrS/g7swl3/qH/BGFG2Hu4" +
-             "RlL48eb3lLKqTt2xKHdCs6Cd4RMfJPYnzgvI4BNrFUKsjkcu+WD4OO2A27Pq1n" +
-             "50cMchmcaXadJhGrOqH5YmHdOCj5NSHzJYrsW0HPlpuAx/ECMeIZYDh6RMqaFM" +
-             "2DXzdKX9NmmyqzJ3o/0lkk/N97gfVRLW5hA29yeAwaCViZNCP8iC9aO0q9fQoj" +
-             "oa7NQnAtw==")
-
-REGISTRATION_PAYLOAD = {
-    "forcePairing": False,
-    "manifest": {
-        "appVersion": "1.1",
-        "manifestVersion": 1,
-        "permissions": [
-            "LAUNCH",
-            "LAUNCH_WEBAPP",
-            "APP_TO_APP",
-            "CLOSE",
-            "TEST_OPEN",
-            "TEST_PROTECTED",
-            "CONTROL_AUDIO",
-            "CONTROL_DISPLAY",
-            "CONTROL_INPUT_JOYSTICK",
-            "CONTROL_INPUT_MEDIA_RECORDING",
-            "CONTROL_INPUT_MEDIA_PLAYBACK",
-            "CONTROL_INPUT_TV",
-            "CONTROL_POWER",
-            "READ_APP_STATUS",
-            "READ_CURRENT_CHANNEL",
-            "READ_INPUT_DEVICE_LIST",
-            "READ_NETWORK_STATE",
-            "READ_RUNNING_APPS",
-            "READ_TV_CHANNEL_LIST",
-            "WRITE_NOTIFICATION_TOAST",
-            "READ_POWER_STATE",
-            "READ_COUNTRY_INFO",
-            "READ_SETTINGS",
-            "CONTROL_TV_SCREEN",
-            "CONTROL_TV_STANBY",
-            "CONTROL_FAVORITE_GROUP",
-            "CONTROL_USER_INFO",
-            "CHECK_BLUETOOTH_DEVICE",
-            "CONTROL_BLUETOOTH",
-            "CONTROL_TIMER_INFO",
-            "STB_INTERNAL_CONNECTION",
-            "CONTROL_RECORDING",
-            "READ_RECORDING_STATE",
-            "WRITE_RECORDING_LIST",
-            "READ_RECORDING_LIST",
-            "READ_RECORDING_SCHEDULE",
-            "WRITE_RECORDING_SCHEDULE",
-            "READ_STORAGE_DEVICE_LIST",
-            "READ_TV_PROGRAM_INFO",
-            "CONTROL_BOX_CHANNEL",
-            "READ_TV_ACR_AUTH_TOKEN",
-            "READ_TV_CONTENT_STATE",
-            "READ_TV_CURRENT_TIME",
-            "ADD_LAUNCHER_CHANNEL",
-            "SET_CHANNEL_SKIP",
-            "RELEASE_CHANNEL_SKIP",
-            "CONTROL_CHANNEL_BLOCK",
-            "DELETE_SELECT_CHANNEL",
-            "CONTROL_CHANNEL_GROUP",
-            "SCAN_TV_CHANNELS",
-            "CONTROL_TV_POWER",
-            "CONTROL_WOL"
-        ],
-        "signatures": [
-            {
-                "signature": SIGNATURE,
-                "signatureVersion": 1
-            }
-        ],
-        "signed": {
-            "appId": "com.lge.test",
-            "created": "20140509",
-            "localizedAppNames": {
-                "": "LG Remote App",
-                "ko-KR": u"리모컨 앱",
-                "zxx-XX": u"ЛГ Rэмotэ AПП"
-            },
-            "localizedVendorNames": {
-                "": "LG Electronics"
-            },
-            "permissions": [
-                "TEST_SECURE",
-                "CONTROL_INPUT_TEXT",
-                "CONTROL_MOUSE_AND_KEYBOARD",
-                "READ_INSTALLED_APPS",
-                "READ_LGE_SDX",
-                "READ_NOTIFICATIONS",
-                "SEARCH",
-                "WRITE_SETTINGS",
-                "WRITE_NOTIFICATION_ALERT",
-                "CONTROL_POWER",
-                "READ_CURRENT_CHANNEL",
-                "READ_RUNNING_APPS",
-                "READ_UPDATE_INFO",
-                "UPDATE_FROM_REMOTE_APP",
-                "READ_LGE_TV_INPUT_EVENTS",
-                "READ_TV_CURRENT_TIME"
-            ],
-            "serial": "2f930e2d2cfe083771f68e4fe7bb07",
-            "vendorId": "com.lge"
-        }
-    },
-    "pairingType": "PROMPT"
-}
-
-
-class WebOSWebSocketClient(WebSocketClient):
-    @property
-    def handshake_headers(self):
-        headers = super(WebOSWebSocketClient, self).handshake_headers
-        return [(k, v) for k, v in headers if k.lower() != 'origin']
-
-
-class WebOSClient(WebOSWebSocketClient):
-    PROMPTED = 1
-    REGISTERED = 2
-
-    def __init__(self, host):
-        ws_url = "ws://{}:3000/".format(host)
-        super(WebOSClient, self).__init__(ws_url)
-        self.waiters = {}
-        self.waiter_lock = RLock()
-        self.subscribers = {}
-        self.subscriber_lock = RLock()
-        self.send_lock = RLock()
-
-    @staticmethod
-    def discover():
-        res = discover("urn:schemas-upnp-org:device:MediaRenderer:1",
-                       keyword="LG", hosts=True, retries=3)
-        return [WebOSClient(x) for x in res]
-
-    def register(self, store, timeout=60):
-        if "client_key" in store:
-            REGISTRATION_PAYLOAD["client-key"] = store["client_key"]
-
-        queue = self.send_message('register', None, REGISTRATION_PAYLOAD,
-                                  get_queue=True)
-        while True:
-            try:
-                item = queue.get(block=True, timeout=timeout)
-            except Empty:
-                raise Exception("Timeout.")
-
-            if item.get("payload", {}).get("pairingType") == "PROMPT":
-                yield WebOSClient.PROMPTED
-            elif item["type"] == "registered":
-                store["client_key"] = item["payload"]["client-key"]
-                yield WebOSClient.REGISTERED
-                break
-            else:
-                # TODO: Better exception.
-                raise Exception("Failed to register.")
-
-    def send_message(self, request_type, uri, payload, unique_id=None,
-                     get_queue=False, callback=None, cur_time=time.time):
-        if unique_id is None:
-            unique_id = str(uuid4())
-
-        if get_queue:
-            wait_queue = Queue()
-            callback = wait_queue.put
-
-        if callback is not None:
-            with self.waiter_lock:
-                self.waiters[unique_id] = (callback, cur_time())
-
-        obj = {"type": request_type, "id": unique_id}
-        if uri is not None:
-            obj["uri"] = uri
-        if payload is not None:
-            obj["payload"] = payload
-
-        with self.send_lock:
-            self.send(json.dumps(obj))
-
-        if get_queue:
-            return wait_queue
-
-    def subscribe(self, uri, unique_id, callback, payload=None):
-        def func(obj):
-            callback(obj.get("payload"))
-
-        with self.subscriber_lock:
-            self.subscribers[unique_id] = uri
-        self.send_message('subscribe', uri, payload, unique_id=unique_id,
-                          callback=func, cur_time=lambda: None)
-        return unique_id
-
-    def unsubscribe(self, unique_id):
-        with self.subscriber_lock:
-            uri = self.subscribers.pop(unique_id, None)
-
-        if not uri:
-            raise ValueError("Subscription not found: {}".format(unique_id))
-
-        with self.waiter_lock:
-            self.waiters.pop(unique_id)
-
-        self.send_message('unsubscribe', uri, payload=None)
-
-    def received_message(self, msg):
-        obj = json.loads(str(msg))
-
-        with self.waiter_lock:
-            self.clear_old_waiters()
-            if "id" in obj and obj["id"] in self.waiters:
-                callback, created_time = self.waiters[obj["id"]]
-                callback(obj)
-
-    def clear_old_waiters(self, delta=60):
-        to_clear = []
-        cur_time = time.time()
-        for key, value in self.waiters.items():
-            callback, created_time = value
-            if created_time and created_time + delta < cur_time:
-                to_clear.append(key)
-
-        for key in to_clear:
-            self.waiters.pop(key)
diff -Naur ./temp/controls.py D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/temp/controls.py
--- ./temp/controls.py	1900-01-00 00:00:00 +0000
+++ D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/temp/controls.py	1900-01-00 00:00:00 +0000
@@ -1,489 +0,0 @@
-try:
-    # begin try for python <= 3.5
-    from collections import Callable
-except ImportError:
-    # after try for python >= 3.10
-    from typing import Callable
-
-from queue import Empty
-from uuid import uuid4
-
-from pywebostv.connection import WebOSWebSocketClient
-from pywebostv.model import Application, InputSource, AudioOutputSource
-
-
-ARGS_NONE = ()
-
-
-def arguments(val, postprocess=lambda x: x, default=ARGS_NONE):
-    if type(val) not in (str, int):
-        raise ValueError("Only numeric indices, or string keys allowed.")
-
-    def func(*args, **kwargs):
-        try:
-            if isinstance(val, int):
-                if default is ARGS_NONE:
-                    return postprocess(args[val])
-                valid_index = 0 <= val < len(args)
-                return postprocess(args[val]) if valid_index else default
-            elif isinstance(val, str):
-                if default is ARGS_NONE:
-                    return postprocess(kwargs[val])
-                return postprocess(kwargs[val]) if val in kwargs else default
-        except (KeyError, IndexError):
-            raise TypeError("Bad arguments.")
-    return func
-
-
-def process_payload(obj, *args, **kwargs):
-    if isinstance(obj, list):
-        return [process_payload(item, *args, **kwargs) for item in obj]
-    elif isinstance(obj, dict):
-        return {k: process_payload(v, *args, **kwargs) for k, v in obj.items()}
-    elif isinstance(obj, Callable):
-        return obj(*args, **kwargs)
-    else:
-        return obj
-
-
-def standard_validation(payload):
-    if not payload.pop("returnValue", None):
-        return False, payload.pop("errorText", "Unknown error.")
-    return True, None
-
-
-class WebOSControlBase(object):
-    COMMANDS = {}
-
-    def __init__(self, client):
-        self.client = client
-        self.subscriptions = {}
-
-    def request(self, uri, params, callback=None, block=False, timeout=60):
-        if block:
-            queue = self.client.send_message('request', uri, params,
-                                             get_queue=True)
-            try:
-                return queue.get(timeout=timeout, block=True)
-            except Empty:
-                raise Exception("Failed.")
-        else:
-            self.client.send_message('request', uri, params, callback=callback)
-
-    def __getattr__(self, name):
-        subscribe_prefix = "subscribe_"
-        unsubscribe_prefix = "unsubscribe_"
-        if name in self.COMMANDS:
-            return self.exec_command(name, self.COMMANDS[name])
-        elif name.startswith(subscribe_prefix):
-            subscribe_name = name.lstrip(subscribe_prefix)
-            sub_cmd_info = self.COMMANDS.get(subscribe_name)
-            if not sub_cmd_info:
-                raise AttributeError(name)
-            elif not sub_cmd_info.get("subscription"):
-                raise AttributeError("Subscription not found or allowed.")
-            else:
-                return self.subscribe(subscribe_name, sub_cmd_info)
-        elif name.startswith(unsubscribe_prefix):
-            unsubscribe_name = name.lstrip(unsubscribe_prefix)
-            sub_cmd_info = self.COMMANDS.get(unsubscribe_name)
-            if not sub_cmd_info:
-                raise AttributeError(name)
-            elif not sub_cmd_info.get("subscription"):
-                raise AttributeError("Subscription not found or allowed.")
-            else:
-                return self.unsubscribe(unsubscribe_name, sub_cmd_info)
-        else:
-            raise AttributeError(name)
-
-    def exec_command(self, cmd, cmd_info):
-        def request_func(*args, **kwargs):
-            callback = kwargs.pop('callback', None)
-            response_valid = cmd_info.get("validation", lambda p: (True, None))
-            return_fn = cmd_info.get('return', lambda x: x)
-            block = kwargs.pop('block', True)
-            timeout = kwargs.pop('timeout', 60)
-            params = process_payload(cmd_info.get("payload"), *args, **kwargs)
-
-            # callback in the args has higher priority.
-            if callback:
-                def callback_wrapper(res):
-                    payload = res.get("payload")
-                    status, message = response_valid(payload)
-                    if not status:
-                        return callback(False, message)
-                    return callback(True, return_fn(payload))
-
-                self.request(cmd_info["uri"], params, timeout=timeout,
-                             callback=callback_wrapper)
-            elif block:
-                res = self.request(cmd_info["uri"], params, block=block,
-                                   timeout=timeout)
-                payload = res.get("payload")
-                status, message = response_valid(payload)
-                if not status:
-                    raise IOError(message)
-
-                return return_fn(payload)
-            else:
-                self.request(cmd_info["uri"], params)
-        return request_func
-
-    def subscribe(self, name, cmd_info):
-        def request_func(callback):
-            response_valid = cmd_info.get("validation", lambda p: (True, None))
-            return_fn = cmd_info.get('return', lambda x: x)
-
-            def callback_wrapper(payload):
-                status, message = response_valid(payload)
-                if not status:
-                    return callback(False, message)
-                return callback(True, return_fn(payload))
-
-            if name in self.subscriptions:
-                raise ValueError("Already subscribed.")
-
-            uid = str(uuid4())
-            self.subscriptions[name] = uid
-            self.client.subscribe(cmd_info["uri"], uid, callback_wrapper)
-        return request_func
-
-    def unsubscribe(self, name, cmd_info):
-        def request_func():
-            uid = self.subscriptions.get(name)
-            if not uid:
-                raise ValueError("Not subscribed.")
-            self.client.unsubscribe(uid)
-            del self.subscriptions[name]
-        return request_func
-
-
-class MediaControl(WebOSControlBase):
-    def list_audio_output_sources(self):
-        sources = ['tv_speaker', 'external_speaker', 'soundbar', 'bt_soundbar', 'tv_external_speaker']
-
-        return [AudioOutputSource(x) for x in sources]
-
-    COMMANDS = {
-        "volume_up": {"uri": "ssap://audio/volumeUp"},
-        "volume_down": {"uri": "ssap://audio/volumeDown"},
-        "get_volume": {
-            "uri": "ssap://audio/getVolume",
-            "validation": standard_validation,
-            "subscription": True,
-        },
-        "set_volume": {
-            "uri": "ssap://audio/setVolume",
-            "args": [int],
-            "payload": {"volume": arguments(0)}
-        },
-        "mute": {
-            "uri": "ssap://audio/setMute",
-            "args": [bool],
-            "payload": {"mute": arguments(0)}
-        },
-        "play": {"uri": "ssap://media.controls/play"},
-        "pause": {"uri": "ssap://media.controls/pause"},
-        "stop": {"uri": "ssap://media.controls/stop"},
-        "rewind": {"uri": "ssap://media.controls/rewind"},
-        "fast_forward": {"uri": "ssap://media.controls/fastForward"},
-        "get_audio_output": {
-            "uri": "ssap://audio/getSoundOutput",
-            "validation": standard_validation,
-            "subscription": True,
-            "return": lambda p: AudioOutputSource(p["soundOutput"])
-        },
-        "set_audio_output": {
-            "uri": "ssap://audio/changeSoundOutput",
-            "args": [AudioOutputSource],
-            "kwargs": {},
-            "payload": {
-                "output": arguments(0, postprocess=lambda source: source.data),
-            },
-            "validation": standard_validation,
-        }
-     }
-
-
-class TvControl(WebOSControlBase):
-    COMMANDS = {
-        "channel_down": {"uri": "ssap://tv/channelDown"},
-        "channel_up": {"uri": "ssap://tv/channelUp"},
-        "set_channel_with_id": {
-            "uri": "ssap://tv/openChannel",
-            "args": [str],
-            "payload": {
-                "channelId": arguments(0)
-            }
-        },
-        "get_current_channel": {
-            "uri": "ssap://tv/getCurrentChannel",
-            "validation": standard_validation,
-            "subscription": True
-        },
-        "channel_list": {"uri": "ssap://tv/getChannelList"},
-        "get_current_program": {
-            "uri": "ssap://tv/getChannelProgramInfo",
-            "validation": standard_validation
-        }
-     }
-
-
-class SystemControl(WebOSControlBase):
-    COMMANDS = {
-        "power_off": {"uri": "ssap://system/turnOff"},
-        "screen_off": {
-            "uri": "ssap://com.webos.service.tvpower/power/turnOffScreen",
-            "payload": {"standbyMode": "active"}
-        },
-        "screen_on": {
-            "uri": "ssap://com.webos.service.tvpower/power/turnOnScreen",
-            "payload": {"standbyMode": "active"}
-        },
-        "info": {
-            "uri": "ssap://com.webos.service.update/getCurrentSWInformation",
-            "validation": standard_validation,
-        },
-        "notify": {
-            "uri": "ssap://system.notifications/createToast",
-            "args": [str],
-            "payload": {"message": arguments(0)}
-        }
-    }
-
-
-class ApplicationControl(WebOSControlBase):
-    COMMANDS = {
-        "list_apps": {
-            "uri": "ssap://com.webos.applicationManager/listApps",
-            "args": [],
-            "kwargs": {},
-            "payload": {},
-            "validation": standard_validation,
-            "return": lambda payload: [Application(x) for x in payload["apps"]]
-        },
-        "launch": {
-            "uri": "ssap://system.launcher/launch",
-            "args": [Application],
-            "kwargs": {"content_id": str, "params": dict},
-            "payload": {
-                "id": arguments(0, postprocess=lambda app: app["id"]),
-                "contentId": arguments("content_id", default=None),
-                "params": arguments("params", default=None)
-            },
-            "validation": standard_validation,
-        },
-        "get_current": {
-            "uri": "ssap://com.webos.applicationManager/getForegroundAppInfo",
-            "args": [],
-            "kwargs": {},
-            "payload": {},
-            "validation": standard_validation,
-            "return": lambda p: p["appId"],
-            "subscription": True,
-        },
-        "close": {
-            "uri": "ssap://system.launcher/close",
-            "args": [dict],
-            "kwargs": {},
-            "payload": arguments(0),
-            "validation": standard_validation,
-        }
-    }
-
-
-class InputControl(WebOSControlBase):
-    COMMANDS = {
-        "type": {
-            "uri": "ssap://com.webos.service.ime/insertText",
-            "args": [str],
-            "payload": {"text": arguments(0), "replace": 0}
-        },
-        "delete": {
-            "uri": "ssap://com.webos.service.ime/deleteCharacters",
-            "args": [int],
-            "payload": {"count": arguments(0)}
-        },
-        "enter": {"uri": "ssap://com.webos.service.ime/sendEnterKey"},
-    }
-
-    INPUT_COMMANDS = {
-        "move": {
-            "command": [["type", "move"],
-                        ["dx", arguments(0)],
-                        ["dy", arguments(1)],
-                        ["down", arguments("drag", default=0)]]
-        },
-        "click": {
-            "command": [["type", "click"]]
-        },
-        "scroll": {
-            "command": [["type", "scroll"],
-                        ["dx", arguments(0)],
-                        ["dy", arguments(1)]]
-        },
-        "left": {
-            "command": [["type", "button"], ["name", "LEFT"]]
-        },
-        "right": {
-            "command": [["type", "button"], ["name", "RIGHT"]]
-        },
-        "down": {
-            "command": [["type", "button"], ["name", "DOWN"]]
-        },
-        "up": {
-            "command": [["type", "button"], ["name", "UP"]]
-        },
-        "home": {
-            "command": [["type", "button"], ["name", "HOME"]]
-        },
-        "back": {
-            "command": [["type", "button"], ["name", "BACK"]]
-        },
-        "menu": {
-            "command": [["type", "button"], ["name", "MENU"]]
-        },
-        "ok": {
-            "command": [["type", "button"], ["name", "ENTER"]]
-        },
-        "dash": {
-            "command": [["type", "button"], ["name", "DASH"]]
-        },
-        "info": {
-            "command": [["type", "button"], ["name", "INFO"]]
-        },
-        "num_1": {
-            "command": [["type", "button"], ["name", "1"]]
-        },
-        "num_2": {
-            "command": [["type", "button"], ["name", "2"]]
-        },
-        "num_3": {
-            "command": [["type", "button"], ["name", "3"]]
-        },
-        "num_4": {
-            "command": [["type", "button"], ["name", "4"]]
-        },
-        "num_5": {
-            "command": [["type", "button"], ["name", "5"]]
-        },
-        "num_6": {
-            "command": [["type", "button"], ["name", "6"]]
-        },
-        "num_7": {
-            "command": [["type", "button"], ["name", "7"]]
-        },
-        "num_8": {
-            "command": [["type", "button"], ["name", "8"]]
-        },
-        "num_9": {
-            "command": [["type", "button"], ["name", "9"]]
-        },
-        "num_0": {
-            "command": [["type", "button"], ["name", "0"]]
-        },
-        "asterisk": {
-            "command": [["type", "button"], ["name", "ASTERISK"]]
-        },
-        "cc": {
-            "command": [["type", "button"], ["name", "CC"]]
-        },
-        "exit": {
-            "command": [["type", "button"], ["name", "EXIT"]]
-        },
-        "mute": {
-            "command": [["type", "button"], ["name", "MUTE"]]
-        },
-        "red": {
-            "command": [["type", "button"], ["name", "RED"]]
-        },
-        "green": {
-            "command": [["type", "button"], ["name", "GREEN"]]
-        },
-        "yellow": {
-            "command": [["type", "button"], ["name", "YELLOW"]]
-        },
-        "blue": {
-            "command": [["type", "button"], ["name", "BLUE"]]
-        },
-        "volume_up": {
-            "command": [["type", "button"], ["name", "VOLUMEUP"]]
-        },
-        "volume_down": {
-            "command": [["type", "button"], ["name", "VOLUMEDOWN"]]
-        },
-        "channel_up": {
-            "command": [["type", "button"], ["name", "CHANNELUP"]]
-        },
-        "channel_down": {
-            "command": [["type", "button"], ["name", "CHANNELDOWN"]]
-        },
-        "play": {
-            "command": [["type", "button"], ["name", "PLAY"]]
-        },
-        "pause": {
-            "command": [["type", "button"], ["name", "PAUSE"]]
-        },
-        "stop": {
-            "command": [["type", "button"], ["name", "STOP"]]
-        },
-        "rewind": {
-            "command": [["type", "button"], ["name", "REWIND"]]
-        },
-        "fastforward": {
-            "command": [["type", "button"], ["name", "FASTFORWARD"]]
-        }
-    }
-
-    def __init__(self, *args, **kwargs):
-        self.ws_class = kwargs.pop('ws_class', WebOSWebSocketClient)
-        super(InputControl, self).__init__(*args, **kwargs)
-
-    def __getattr__(self, name):
-        if name in self.INPUT_COMMANDS:
-            return self.exec_mouse_command(name, self.INPUT_COMMANDS[name])
-        if name in self.COMMANDS:
-            return super(InputControl, self).__getattr__(name)
-        raise AttributeError(name)
-
-    def connect_input(self):
-        uri = "ssap://com.webos.service.networkinput/getPointerInputSocket"
-        res = self.request(uri, None, block=True)
-        sock_path = res.get("payload").get("socketPath")
-        if not sock_path:
-            raise IOError("Unable to connect to mouse.")
-        self.mouse_ws = self.ws_class(sock_path)
-        self.mouse_ws.connect()
-
-    def disconnect_input(self):
-        self.mouse_ws.close()
-
-    def exec_mouse_command(self, cmd_name, cmd_info):
-        def request_func(*args, **kwargs):
-            params = process_payload(cmd_info["command"], *args, **kwargs)
-            payload = "\n".join(":".join(str(y) for y in x) for x in params)
-            payload += "\n\n"
-            self.mouse_ws.send(payload)
-        return request_func
-
-
-class SourceControl(WebOSControlBase):
-    COMMANDS = {
-        "list_sources": {
-            "uri": "ssap://tv/getExternalInputList",
-            "args": [],
-            "kwargs": {},
-            "payload": {},
-            "validation": standard_validation,
-            "return": lambda p: [InputSource(x) for x in p["devices"]],
-        },
-        "set_source": {
-            "uri": "ssap://tv/switchInput",
-            "args": [InputSource],
-            "kwargs": {},
-            "payload": {
-                "inputId": arguments(0, postprocess=lambda inp: inp["id"]),
-            },
-            "validation": standard_validation,
-        },
-    }
diff -Naur ./temp/discovery.py D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/temp/discovery.py
--- ./temp/discovery.py	1900-01-00 00:00:00 +0000
+++ D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/temp/discovery.py	1900-01-00 00:00:00 +0000
@@ -1,69 +0,0 @@
-import socket
-try:
-    from urlparse import urlparse
-except ImportError:
-    from urllib.parse import urlparse
-
-import requests
-
-
-def read_location(resp, keyword=None):
-    if not isinstance(resp, str):
-        resp = resp.decode('utf-8')
-
-    for line in resp.splitlines():
-        line = line.lower()
-        header = "location: "
-        if line.startswith(header):
-            return line[len(header):]
-
-
-def validate_location(location, keyword, timeout=5):
-    if isinstance(keyword, str):
-        keyword = keyword.encode()
-
-    try:
-        content = requests.get(location, timeout=timeout).content
-        if not keyword:
-            return True
-        return keyword in content
-    except requests.exceptions.RequestException:
-        return False
-
-
-# Adapted from Dan Krause (https://gist.github.com/dankrause/6000248)
-def discover(service, keyword=None, hosts=False, retries=1, timeout=5, mx=3):
-    group = ('239.255.255.250', 1900)
-    locations = set()
-    seen = set()
-
-    message = "\r\n".join([
-        'M-SEARCH * HTTP/1.1',
-        'HOST: {0}:{1}',
-        'MAN: "ssdp:discover"',
-        'ST: {st}',
-        'MX: {mx}',
-        '', '']).format(*group, st=service, mx=mx).encode('ascii')
-
-    for _ in range(retries):
-        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM,
-                             socket.IPPROTO_UDP)
-        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
-        sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 2)
-        sock.settimeout(timeout)
-        sock.sendto(message, group)
-
-        while True:
-            try:
-                location = read_location(sock.recv(1024))
-                if location and location not in seen:
-                    seen.add(location)
-                    if validate_location(location, keyword, timeout=timeout):
-                        locations.add(location)
-            except socket.timeout:
-                break
-
-    if hosts:
-        return {urlparse(x).hostname for x in locations}
-    else:
-        return {x for x in locations}
diff -Naur ./temp/model.py D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/temp/model.py
--- ./temp/model.py	1900-01-00 00:00:00 +0000
+++ D:/Documents/!Projects/EventGhost/egWebOS/egWebOS/pywebostv/temp/model.py	1900-01-00 00:00:00 +0000
@@ -1,30 +0,0 @@
-
-class Application(object):
-    def __init__(self, data):
-        self.data = data
-
-    def __getitem__(self, val):
-        return self.data[val]
-
-    def __repr__(self):
-        return "<Application '{}'>".format(self["title"])
-
-
-class InputSource(object):
-    def __init__(self, data):
-        self.data = data
-        self.label = data["label"]
-
-    def __getitem__(self, val):
-        return self.data[val]
-
-    def __repr__(self):
-        return "<InputSource '{}'>".format(self["label"])
-
-
-class AudioOutputSource(object):
-    def __init__(self, data):
-        self.data = data
-
-    def __repr__(self):
-        return "<AudioOutputSource '{}'>".format(self.data)
